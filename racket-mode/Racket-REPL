450
(string-append "ab" "cd")
(string->int "3")
(~v 3)
(~s "3")
(~v "3")
(~v 3)
(+ '(1 2) '(3 4))
(map + '(1 2) '(3 4))
(map + '(1 2) '(3 4 5))


(take '(1 2 3 4) 2)
(+ 1 2)
(take )
(take '(1 2 3 4 5) 2)
(take '(1 2 3 4 5) 2)
input
(append '(1 2) '(3 4))
((+ 1 2) . 3)

(step-fish baby-input)

(step-fish baby-input)
(stepper baby-input 256)
(define a (make-vector 8))
a
(vector-ref a 0)
(vector-ref a 7)
(vector-ref a 8)
(vector-set! a 0 1)
a
(take 3 '(1 2 3 4))
(take 3 '(1 2 3 4))
(take '(1 2 3 4) 3)
(define a (make-vector 9))
(vector-ref a 8)
(vector-ref a 9)
(better-stepper '(0 0 0 0 0 0 0 0) 1)
(better-stepper '(0 0 0 0 0 0 0 0 0) 1)
(better-stepper '(0 1 0 5 6 0 1 2 2 3 7 8) 1)
(better-stepper '(0 1 0 5 6 0 1 2 2 3 7 8) 0)
(better-stepper '(0 1 0 5 6 0 1 2 2 3 7 8) 0)
(better-stepper '(0 1 0 5 6 0 1 2 2 3 7 8) 1)
(append '(1 2) '(3 4))
(better-stepper '(0 1 0 5 6 0 1 2 2 3 7 8) 1)
(better-stepper '(0 1 0 5 6 0 1 2 2 3 7 8) 1)
(zip '(1 2) '(3 4 5) '(6 7))
(list? '(1 . 2))
(apply + '(1 2 3) '(4 5 6))
(apply + '(1 2 3))
(apply map + '(1 2 3) '(4 5 6))
(map apply + '(1 2 3) '(4 5 6))
(map (cut apply + <>) '(1 2 3) '(4 5 6))
(split-at '(1 2 3 4 5) 2)
(vector-drop #(1 2 3 4) 2)
(take '(1 2 3) 1)
(take '(1 2 3) 1)
(append '(split-at '(1 2 3 4 5) 2))
(append (split-at '(1 2 3 4 5) 2))
(split-at '(1 2 3 4 5 6 7 8 9) 6)
(values 1 2)
(call-with-values (split-at '(0 1 2 3 4 5 6 7 8) 6) +)
(values 1 2)
(call-with-values (split-at '(0 1 2 3 4 5 6 7 8) 6) +)
(call-with-values (split-at '(0 1 2 3 4 5 6 7 8) 6) identity)
(call-with-values (split-at '(0 1 2 3 4 5 6 7 8) 6) append)
(call-with-values (values 1 2) +)
(call-with-values (lambda () (values 1 2)) +)
(slice-up '(1 2 3 4) 2)
(slice-up '(1 2 3 4) 3)
(slice-up '(1 2 3 4) 3)
(slice-up2 '(1 2 3 4) 3)
(slice-up2 '(1 2 3 4) 2)
(slice-up2 '(1 2 3 4) 2)
(slice-up2 '(1 2 3 4) 2)
(cdr (list 1))
(null? (cdr (list 1)))
(null? (cdr (list 1)))
(slice-up2 '(1 2 3 4) 2)
(slice-up2 '(1 2 3 4) 3)
(exp 2 100)
(exponent 2 100)
(exp 100)
(expt 2 1000)
(expt 2 10000)
(stepper input 9999999)
(open-day 4)
(car (open-day 4))
(pair-up (pair-up '(1 2 3 4)))
(pair-up (pair-up '(1 2 3 4 5 6 7 8 )))
(get-basin-size test-input '(0 . 1))
(low-points input)
(compose length car '((1 2 3)))
((compose length car) '((1 2 3)))
(curry + 1 )
(set)
(set 1 2)
(member 1(set 1 2))
(andmap (cut < 3) '(1 2))
(andmap (cut < 3 <>) '(1 2))
(andmap (cut < <> 3) '(1 2))
(range 3)
(<. '(1 2) '(2 3))
(+. '(1 2) '(2 3))
(map. < '(1 2) '(2 3))
(andmap. < '(1 2) '(2 3))
(andmap < '(1 2) '(2 3))
(< 0 1 2)
(1 2 1)
(< 1 2 1)
(andmap < '(1 2 3) (2 3 4))
(andmap < '(1 2 3) '(2 3 4))
(apply andmap < '((1 2) (3 4) (5 6)))
(vector-ref #(1 2) 0)
(vector-map + #(1 2) #(3 4))
(vector-map + #(1 2) #(3 4))
(array+ #(1 2) #(3 4))
(vector+ #(1 2) #(3 4))
(vector-map + #(1 2) #(3 4))
(andmap < #(1 2))
(vector-map < #(1 2) #(3 4))
(apply and (vector-map < #(1 2) #(3 4))))
(apply and (vector-map < #(1 2) #(3 4)))
(number? +inf.0)
(car input)
(car input)
(car input)
get
(equal? #\( #\()
(assoc #\) scores)
(cadr (assoc #\) scores))
(and 3)
incompletes
(car incompletes)
(car incompletes)
(checker (car incompletes))
(checker (car incompletes))
(car incompletes)
(foldl + 0 '(1 2 3))
(remainder 7 2)
(quotient 7 2)
(sort '(1 2 3 4) <=)
(list-ref '(1 2 3) 2)
(incompletes)
incompletes
corrupted
(median '(1 2 3 4 5))
(< 1 2 +inf.0)
(< +inf.0 +inf.0)
(curry + 2 3)
(define x '((1 2 3) (4 5 6) (7 8 9)))
(lrrp x '(1 1) 999)
x
(range 5ž)
(range 5)
(range 5)
(neighbors '(1 1) directions 5 5)
(= 3 $)
(= 3 #f)
(eq? 3 #f)
(equal? 3 #f)
(step test-input 5 5)
(step test-input 5 5)
(count zero? (flatten (step test-input 5 5)))
(step test-input 5 5)
(filter zero? '(0 0 0))
(filter zero? '(0 1 0))
(empty? (filter-not zero? '(0 1 0)))
(empty? (filter-not zero? '(0 0 0)))
(not 2)
(length (make-paper numbers))
(quotient 5 2)
(apply max (map cadr (set->list numbers)))
(split-at 2 '(1 2 3 4 5 6))
(split-at 2 '(1 2 3 4 5 6))
(split-at '(1 2 3 4 5 6)) 2
(split-at '(1 2 3 4 5 6) 2) 
(split-at '(1 2 3 4 5 6) 3) 
(take-right '(1 2 3 4 5) 3)
(take-right '(1 2 3 4 5) 2)
(take '(1 2 3 4 5) 2)
(apply max '(1 2 3))
(apply max '((1 2) (2 3) (3 4)))
'((1 2) (2 3) (3 4))
(map car '((1 2) (2 3) (3 4)))
(map (split-at 1) '((1 2) (2 3) (3 4)))
(map (curry split-at 1) '((1 2) (2 3) (3 4)))
(map (curryr split-at 1) '((1 2) (2 3) (3 4)))
(foldl (λ(l a) (list (max (car l) (car a)) (max (cadr l) (cadr a)))) '(-1 -1) '((1 2) (2 3) (3 4)))
(values (foldl (λ(l a) (list (max (car l) (car a)) (max (cadr l) (cadr a)))) '(-1 -1) '((1 2) (2 3) (3 4))))
(apply max '(1 2) '(3 4))
(map max '(1 2) '(3 4))
(map max '((1 2) '(3 4) '(5 6)))
(map (apply max) '((1 2) '(3 4) '(5 6)))
(apply map (apply max) '((1 2) '(3 4) '(5 6)))
(apply map max '((1 2) '(3 4) '(5 6)))
(apply map max '((1 2) (3 4) (5 6)))
(map inc-odd (apply map max '((1 2) (3 4) (5 6) (7 8))))
(apply map max '((1 2) (3 4) (5 6) (7 8)))
(apply map max '((1 2) (3 4) (5 6) (7 8)))
(map inc-odd (apply map max '((1 2) (3 4) (5 6) (7 8))))
(values (map inc-odd (apply map max '((1 2) (3 4) (5 6) (7 8)))))
(apply values (map inc-odd (apply map max '((1 2) (3 4) (5 6) (7 8)))))
(open-day 13)
(split-at (open-day 13) (index-of (open-day 13) 'fold))
(remove-duplicates '(fold
  along
  x=655
  fold
  along
  y=447
  fold
  along
  x=327
  fold
  along
  y=223
  fold
  along
  x=163
  fold
  along
  y=111
  fold
  along
  x=81
  fold
  along
  y=55
  fold
  along
  x=40
  fold
  along
  y=27
  fold
  along
  y=13
  fold
  along
  y=6))
(make-thingies-alt (open-day 13))
(make-thingies-alt (open-day 13))
(apply map max '((1 2) (3 4)))
(ormap identity '(#f #t) '(#f #t))
(apply ormap identity '(#f #t) '(#f #t))
(ormap '(#f #t))
(ormap identity '(#f #t))
'((#t #f #t) (#f #t #f) (#f #f #f))
'(#t #f #t)
'(#f #f #f)
'((#t #f #t))
'((#f #f #f))
(define top '((#t #f #t)))
(define bot '((#f #f #f)))
(map () top (reverse bot))
(map (curry map (apply ormap identity)) top (reverse bot))
(map (curry map (curry apply ormap identity)) top (reverse bot))
(map (curry ormap identity) top (reverse bot))
(map (curry ormap) top (reverse bot))
(foldl (curry map max) '((1 2) (3 4) (5 )))
(foldl (curry map max) '((1 2) (3 4) (5 6)))
(reduce (curry map max) '((1 2) (3 4) (5 6)))
(foldl (curry map max) '(1 2) '((1 2) (3 4) (5 6)))
(printer (foldl fold (make-paper numbers) (take folds 4)))
(printer (foldl fold (make-paper numbers) (take folds 5)))
(printer (foldl fold (make-paper numbers) (take folds 6)))
(printer (foldl fold (make-paper numbers) (take folds 7)))
(printer (foldl fold (make-paper numbers) (take folds 8)))
(printer (foldl fold (make-paper numbers) (take folds 9)))
(printer (foldl fold (make-paper numbers) (take folds 10)))
(printer (foldl fold (make-paper numbers) (take folds 11)))
(printer (foldl fold (make-paper numbers) (take folds 12)))
folds
folds
starting-sequence
rules
(step starting-seq rules)
(step starting-seq rules)
(repeater (curryr step rules) starting-seq 4)
(mapcar (curry list) starting-seq (cdr starting-seq))
(mapcar (cut list <> <>) starting-seq (cdr starting-seq))
(- 3497 322)
(/ (- 3497 322) 2)
(quotient (- 3497 322) 2)
(ceiling (/ (- 3497 322) 2))
(last '(1 2 3))
(eq? (compose identity identity) identity)
(equal? (compose identity identity) identity)
(compose identity identity)
identity
(length test-input)
(neighbors '(0 0) directions 10 10)
(fib 10)
(time (fib 40))
(= 2 2 2)
(= 2 (1 + 1) 2)
(= 2 (1 . + . 1) 2)
 (eq? '(1 2) '(1 2))
 (equal? '(1 2) '(1 2))
(remove)
(remove '(1 0) '((1 0) (0 1) (-1 0)))
input
(char->string #\D)
(hexint->digit 0)
(hexint->digit 0)
(hexint->digit 15)
(hexint->digit 1)
(hexint->digit 2)
(quotient 15 8)
(hexchar->binary #\F)
"#x03BB"
"#b03BB"
(string->integer "#b03BB")
(string->number "#b03BB")
(string->number "#x03BB")
(modulo 5 1)
